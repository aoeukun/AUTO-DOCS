{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Automatic Code Documentation \ud83d\ude80","text":"<p>Welcome to Auto Code Docs \u2014 where your code meets intelligence.</p> <p>Imagine a world where your Python codebase documents itself \u2014 beautifully, intelligently, and automatically. That's what we built. Sit back and let AI do the heavy lifting while you focus on creating brilliant software.</p>"},{"location":"#why-this-project","title":"\u2728 Why This Project?","text":"<p> \"90% Of developers hate writing docs. The other 10% are lying.\" \u2013 Every Developer Ever</p> <p> Writing documentation is tedious. But it's essential for collaboration, onboarding, and maintaining high-quality software. So we asked:</p> <p>What if your code could explain itself?</p> <p>This project answers that with a seamless pipeline that analyzes your code using an LLM, extracts meaningful descriptions, and turns it all into a fully-deployed website \u2014 without you writing a single docstring.</p>"},{"location":"#features-youll-love","title":"\ud83d\udd25Features You'll Love","text":"<ul> <li> <p>\ud83e\udde0 AI-Powered Clarity   Uses Gemini-Api to analyze your code and generate intelligent documentation.</p> </li> <li> <p>\ud83d\udee0\ufe0f Seamless Automation   Set it and forget it \u2014 every push to GitHub triggers automatic doc generation and deployment.</p> </li> <li> <p>\ud83d\udcda Beautiful MkDocs Site   Clean, responsive, and easy to navigate. Built with MkDocs and deployed with GitHub Pages.</p> </li> <li> <p>\ud83d\ude80 Lightning-Fast Setup   Drop in your code,push to github, and you\u2019re done. It's that easy.</p> </li> </ul>"},{"location":"#real-time-updates","title":"\ud83d\udd04 Real-Time Updates","text":"<ul> <li>Documentation is regenerated and updated every time you push new code to the repository.</li> <li>Automatically deployed to GitHub Pages for seamless access.</li> </ul>"},{"location":"#github-pages-deployment","title":"\ud83c\udf0d GitHub Pages Deployment","text":"<ul> <li>View your project documentation live via GitHub Pages at any time.</li> <li>Always up-to-date, accessible from anywhere.</li> </ul>"},{"location":"#how-it-works","title":"\ud83e\udde0 How It Works","text":"<ol> <li> <p>Push Code:    Whenever you push changes to the <code>main</code> branch, the workflow automatically triggers.</p> </li> <li> <p>Generate Documentation:    The system uses the Gemini API to analyze and generate detailed, human-readable documentation.</p> </li> <li> <p>Markdown Generation    The documentation is converted into <code>.md</code> files stored under <code>docs/generated/</code>.</p> </li> <li> <p>Deploy the Site:    All documentation is then deployed to GitHub Pages, making it instantly available.</p> </li> </ol>"},{"location":"#tech-stack","title":"\ud83d\udee0 Tech Stack","text":"Tool Purpose \ud83e\udde0 Gemini-2.0 LLM for doc generation \ud83d\udc0d Python Script for parsing and generation \ud83d\udcd8 MkDocs Static site generator \ud83d\udef8 GitHub Actions Automated deployment \ud83d\udd35 VS Code Code editor"},{"location":"#made-with-passion","title":"Made With Passion","text":"<p>This project isn\u2019t just about automation \u2014 it\u2019s about empowering developers to write less and deliver more.</p> <p>Because when your code can speak for itself... you just code.</p>    \u2014 Created by S.Sandeep Kumar"},{"location":"generated/Fibonacci/","title":"Documentation for <code>Fibonacci.py</code>","text":"<pre><code>\"\"\"\nThis script generates and prints a Fibonacci sequence up to a specified limit.\n\nThe user is prompted to enter an integer limit, and the program calculates\nand displays the Fibonacci numbers that are less than or equal to this limit.\n\"\"\"\n\ndef fibonacci(n):\n    \"\"\"\n    Generates a Fibonacci sequence where each number is less than or equal to n.\n\n    The sequence starts with 0 and 1. Each subsequent number is the sum of the\n    two preceding ones. The generation stops when the next number in the sequence\n    would exceed the limit 'n'.\n\n    Args:\n        n (int): The maximum value for any number included in the sequence.\n                 Must be a non-negative integer.\n\n    Returns:\n        list[int]: A list containing the Fibonacci sequence with values\n                   less than or equal to 'n'. The list will always start\n                   with [0, 1] if n &gt;= 1, or [0] if n = 0.\n    \"\"\"\n    if n &lt; 0:\n        # Fibonacci sequence is typically defined for non-negative integers.\n        # Returning an empty list for negative input is a reasonable approach.\n        return []\n    if n == 0:\n        # If the limit is 0, the sequence contains only 0.\n        return [0]\n    if n == 1:\n         # If the limit is 1, the sequence contains 0 and 1.\n         return [0, 1]\n\n    # Initialize the sequence with the first two Fibonacci numbers.\n    sequence = [0, 1]\n\n    # Continue adding to the sequence as long as the next number is &lt;= n.\n    # The next number is the sum of the last two numbers in the current sequence.\n    while sequence[-1] + sequence[-2] &lt;= n:\n        next_fib = sequence[-1] + sequence[-2] # Calculate the next Fibonacci number.\n        sequence.append(next_fib) # Add the next number to the sequence.\n\n    return sequence\n\n# Prompt the user to enter the upper limit for the sequence.\n# The input is converted to an integer.\nlimit = int(input(\"Generate Fibonacci sequence up to: \"))\n\n# Call the fibonacci function with the user-provided limit\n# and print the resulting sequence.\nprint(fibonacci(limit))\n</code></pre>"},{"location":"generated/caculator/","title":"Documentation for <code>caculator.py</code>","text":"<pre><code>\"\"\"\nA simple command-line calculator script.\n\nThis script provides basic arithmetic operations (addition, subtraction,\nmultiplication, division) and a user interface to perform these calculations.\n\"\"\"\n\ndef add(x, y):\n    \"\"\"\n    Adds two numbers.\n\n    Args:\n        x (float): The first number.\n        y (float): The second number.\n\n    Returns:\n        float: The sum of x and y.\n    \"\"\"\n    return x + y\n\ndef subtract(x, y):\n    \"\"\"\n    Subtracts the second number from the first.\n\n    Args:\n        x (float): The first number (minuend).\n        y (float): The second number (subtrahend).\n\n    Returns:\n        float: The difference between x and y.\n    \"\"\"\n    return x - y\n\ndef multiply(x, y):\n    \"\"\"\n    Multiplies two numbers.\n\n    Args:\n        x (float): The first number.\n        y (float): The second number.\n\n    Returns:\n        float: The product of x and y.\n    \"\"\"\n    return x * y\n\ndef divide(x, y):\n    \"\"\"\n    Divides the first number by the second.\n\n    Handles division by zero by returning an error message.\n\n    Args:\n        x (float): The numerator.\n        y (float): The denominator.\n\n    Returns:\n        float or str: The quotient of x and y, or an error message if y is zero.\n    \"\"\"\n    if y == 0:\n        # Check for division by zero\n        return \"Error! Division by zero.\"\n    return x / y\n\ndef calculator():\n    \"\"\"\n    Runs the main calculator application loop.\n\n    Presents a menu of operations, takes user input for the choice and numbers,\n    performs the selected operation, and prints the result. Handles invalid\n    input for both operation choice and number values.\n    \"\"\"\n    print(\"Simple Calculator\")\n    print(\"Select operation:\")\n    print(\"1. Add\")\n    print(\"2. Subtract\")\n    print(\"3. Multiply\")\n    print(\"4. Divide\")\n\n    # Get user choice\n    choice = input(\"Enter choice (1/2/3/4): \")\n\n    # Validate user choice\n    if choice in ('1', '2', '3', '4'):\n        try:\n            # Get numbers from user\n            num1 = float(input(\"Enter first number: \"))\n            num2 = float(input(\"Enter second number: \"))\n        except ValueError:\n            # Handle non-numeric input\n            print(\"Invalid input. Please enter numeric values.\")\n            return # Exit function if input is invalid\n\n        # Perform the selected operation and print result\n        if choice == '1':\n            print(f\"Result: {add(num1, num2)}\")\n        elif choice == '2':\n            print(f\"Result: {subtract(num1, num2)}\")\n        elif choice == '3':\n            print(f\"Result: {multiply(num1, num2)}\")\n        elif choice == '4':\n            print(f\"Result: {divide(num1, num2)}\")\n    else:\n        # Handle invalid operation choice\n        print(\"Invalid choice ! Please select a valid operation.\")\n\n# Main execution block\nif __name__ == \"__main__\":\n    # Call the calculator function when the script is run directly\n    calculator()\n</code></pre>"},{"location":"generated/check_even_odd/","title":"Documentation for <code>check_even_odd.py</code>","text":"<pre><code>\"\"\"\nThis script determines whether a given number is even or odd.\n\nIt prompts the user to enter an integer and then uses the modulo operator\nto check for divisibility by 2. The result is printed to the console,\nindicating whether the input number is even or odd.\n\"\"\"\n\n# Ask the user for a number and convert it to an integer.\nnum = int(input(\"Enter a number: \"))\n\n# Check if the number is even or odd using the modulo operator (%).\n# If the remainder of the division by 2 is 0, the number is even.\nif num % 2 == 0:\n    print(\"The number is even.\")\nelse:\n    print(\"The number is odd.\")\n</code></pre>"},{"location":"generated/gen/","title":"Documentation for <code>gen.py</code>","text":"<pre><code>\"\"\"\nThis script generates documentation for Python code files using the Google Gemini API\nand updates the navigation configuration of an mkdocs.yml file to include the\ngenerated documentation pages.\n\nIt reads source files from a specified directory, calls the Gemini API to\ngenerate markdown documentation for each file, saves the documentation to\nmarkdown files in an output directory, and then modifies the mkdocs.yml\nfile to add a 'Generated Docs' section in the navigation.\n\"\"\"\n\nimport os\nimport json\nfrom pathlib import Path\nimport yaml\nfrom dotenv import load_dotenv\nimport google.generativeai as genai\n\n# Load environment variables from a .env file\nload_dotenv()\n\n# Retrieve the Google API key from environment variables\nAPI_KEY = os.getenv(\"GOOGLE_API_KEY\")\n\n# Gemini API configuration\ngenai.configure(api_key=API_KEY)\n\n# Specify the name of the Gemini model to use for documentation generation\nMODEL_NAME = \"models/gemini-2.0-flash-thinking-exp-01-21\"\n\n# System prompt provided to the Gemini model to instruct it on documentation generation\nSYSTEM_PROMPT = \"\"\"Act as a Python code documentation assistant. Your task is to add comprehensive documentation to the provided Python code snippet, making it clear, understandable, and maintainable.\n\n**Instructions:**\n\n1.  **Analyze the Code:** Understand the purpose and logic of the provided Python code.\n2.  **Add Docstrings:**\n    * Include a **module-level docstring** at the very beginning of the script explaining its overall purpose and functionality.\n    * Add **function/method/class docstrings** immediately following their definition lines (`def` or `class`).\n    * Follow a clear and standard convention, preferably **Google style**:\n        * Start with a concise one-line summary (using the imperative mood, e.g., \"Calculate...\" not \"Calculates...\"). End with a period.\n        * Include a blank line after the summary if more detail follows.\n        * Add further elaboration on the object's purpose or logic if necessary.\n        * Use an `Args:` section to detail each parameter (`parameter_name (type): Description of the parameter.`).\n        * Use a `Returns:` section to detail the return value (`type: Description of the return value.`). If the function doesn't return anything explicitly (returns `None`), you can state that or omit the section.\n        * Use a `Raises:` section (if applicable) to detail any specific exceptions the code might intentionally raise (`ExceptionType: Condition under which it's raised.`).\n3.  **Add Inline Comments:** Insert inline comments (`#`) judiciously to clarify specific lines or blocks of code that involve complex logic, non-obvious operations, or important algorithmic steps. Avoid commenting on obvious code.\n4.  **Maintain Code Integrity:** Do not change the original code's logic or functionality. Only add documentation elements (docstrings and comments).\n5.  **Output Format:** Return the *complete* Python code, including the original logic, with all the added docstrings and relevant inline comments integrated directly into the code. Ensure the output is presented as a single, well-formatted Python code block.\n\n**Python Code to Document:**\n\"\"\"\n\ndef call_gemini(code: str) -&gt; str:\n    \"\"\"\n    Calls the configured Gemini model to generate documentation for a given Python code snippet.\n\n    Args:\n        code (str): The Python code snippet for which documentation is to be generated.\n\n    Returns:\n        str: The text response from the Gemini model, expected to be the generated documentation.\n    \"\"\"\n    # Instantiate the generative model\n    model = genai.GenerativeModel(MODEL_NAME)\n    # Send the system prompt and the user's code wrapped in a markdown code block\n    response = model.generate_content([\n        {\"role\": \"user\", \"parts\": [{\"text\": f\"{SYSTEM_PROMPT}\\n```python\\n{code}\\n```\"}]}\n    ])\n    return response.text\n\ndef generate_docs(code_path: Path, output_path: Path):\n    \"\"\"\n    Reads a Python code file, generates documentation using `call_gemini`,\n    and writes the documentation to a markdown file.\n\n    Args:\n        code_path (Path): The path to the input Python code file.\n        output_path (Path): The path where the output markdown documentation\n                            file should be saved.\n    \"\"\"\n    # Read the content of the Python code file\n    code = code_path.read_text(encoding=\"utf-8\")\n    # Generate documentation using the Gemini model\n    documentation = call_gemini(code)\n\n    # Ensure the parent directory for the output file exists\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    # Write the generated documentation to the output markdown file\n    # Adds a header indicating the source file\n    output_path.write_text(f\"# Documentation for `{code_path.name}`\\n\\n{documentation}\", encoding=\"utf-8\")\n\ndef update_mkdocs_yml():\n    \"\"\"\n    Updates the mkdocs.yml file's navigation section to include links to\n    the generated documentation markdown files.\n\n    It reads the existing mkdocs configuration, finds all generated markdown\n    files in a specific directory, builds a new 'Generated Docs' navigation\n    item, removes any existing 'Generated Docs' section, and adds the new one.\n    \"\"\"\n    # Define the directory where generated markdown files are stored\n    GENERATED_DIR = Path(\"docs/generated\")\n    # Define the path to the mkdocs configuration file\n    MKDOCS_YML_PATH = Path(\"mkdocs.yml\")\n\n    # Read the existing mkdocs.yml configuration\n    with open(MKDOCS_YML_PATH, \"r\", encoding=\"utf-8\") as f:\n        config = yaml.safe_load(f)\n\n    # Find all markdown files in the generated documentation directory\n    files = [f for f in GENERATED_DIR.iterdir() if f.suffix == \".md\"]\n    # Sort the files alphabetically for consistent navigation order\n    files.sort()\n\n    # Build the new navigation list, removing any previous 'Generated Docs' section\n    new_nav = []\n    for item in config.get(\"nav\", []):\n        # Check if the item is a dictionary and contains the 'Generated Docs' key\n        if isinstance(item, dict) and \"Generated Docs\" in item:\n            # Skip this item (the old generated section)\n            continue\n        # Keep all other navigation items\n        new_nav.append(item)\n\n    # Create the structure for the new 'Generated Docs' navigation section\n    generated_section = {\"Generated Docs\": []}\n    # Add each generated markdown file to the 'Generated Docs' section\n    for file in files:\n        # Create a title from the file name (e.g., 'my_module.md' -&gt; 'My Module')\n        title = file.stem.replace(\"_\", \" \").title()\n        # Add the file to the navigation list within the generated section\n        generated_section[\"Generated Docs\"].append({title: f\"generated/{file.name}\"})\n\n    # Append the newly created 'Generated Docs' section to the navigation\n    new_nav.append(generated_section)\n    # Update the navigation configuration in the main config dictionary\n    config[\"nav\"] = new_nav\n\n    # Write the updated configuration back to mkdocs.yml\n    # sort_keys=False maintains the original order of other nav items\n    with open(MKDOCS_YML_PATH, \"w\", encoding=\"utf-8\") as f:\n        yaml.dump(config, f, sort_keys=False)\n\n    # Print a success message\n    print(\"\u2705 mkdocs.yml updated successfully.\")\n\ndef main():\n    \"\"\"\n    Main function to orchestrate the documentation generation and mkdocs update process.\n\n    Iterates through all Python files in the 'src' directory (including subdirectories),\n    generates documentation for each, saves it to the 'docs/generated' directory,\n    and finally updates the mkdocs navigation.\n    \"\"\"\n    # Define the source directory containing Python files\n    src_dir = Path(\"src\")\n    # Define the output directory for generated markdown files\n    out_dir = Path(\"docs/generated\")\n\n    # Iterate through all files ending with .py in the source directory and its subdirectories\n    for file in src_dir.rglob(\"*.py\"):\n        # Generate documentation for the current Python file\n        # The output path is constructed based on the source file name (without extension)\n        generate_docs(file, out_dir / f\"{file.stem}.md\")\n\n    # After generating documentation for all files, update the mkdocs.yml file\n    update_mkdocs_yml()\n\n    # Print a final completion message\n    print(\"\ud83c\udf89 Documentation generated and mkdocs navigation updated.\")\n\n# Entry point of the script\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"generated/prime/","title":"Documentation for <code>prime.py</code>","text":"<pre><code>\"\"\"This module provides a function to check if a number is prime.\n\nIt includes the `is_prime` function and demonstrates its usage by\ntesting numbers from 1 to 20.\n\"\"\"\n\ndef is_prime(n):\n    \"\"\"Check if a number is a prime number.\n\n    A prime number is a natural number greater than 1 that has no\n    positive divisors other than 1 and itself. This function efficiently\n    checks for divisors up to the square root of the input number.\n\n    Args:\n        n (int): The integer to check for primality. Must be a positive integer.\n\n    Returns:\n        bool: True if n is prime, False otherwise.\n    \"\"\"\n    # Numbers less than or equal to 1 are not prime by definition\n    if n &lt;= 1:\n        return False\n\n    # Check for divisibility from 2 up to the square root of n.\n    # We only need to check up to the square root because if n has a\n    # divisor greater than its square root, it must also have a divisor\n    # less than its square root.\n    # The +1 is needed because the range end is exclusive.\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        # If n is divisible by i with no remainder, then n is not prime\n        if n % i == 0:\n            return False\n\n    # If no divisors were found in the tested range, the number is prime\n    return True\n\n# Demonstrate the usage of the is_prime function\nprint(\"Testing primality for numbers from 1 to 20:\")\n# Test the function for numbers 1 through 20\nfor num in range(1, 21):\n    # Print the number and whether it is identified as prime by the function\n    print(f\"{num} is prime? {is_prime(num)}\")\n\n</code></pre>"},{"location":"generated/sample/","title":"Documentation for <code>sample.py</code>","text":"<pre><code>\"\"\"\nThis is a simple Python program demonstrating basic output and arithmetic operations.\n\nIt prints a standard greeting message to the console.\nIt then initializes two integer variables, calculates their sum, and prints the result\nin a formatted string. This serves as a fundamental example of variable assignment,\narithmetic operations, and printing output in Python.\n\"\"\"\n\n# Print a classic greeting message to the standard output.\nprint(\"Hello, World!\")\n\n# Initialize the first number.\na = 5\n# Initialize the second number.\nb = 3\n\n# Perform an addition operation to find the sum of 'a' and 'b'.\nsum = a + b\n\n# Print the result of the addition.\n# Uses string concatenation with variables to display the calculation details\n# and the final sum in a human-readable format.\nprint(\"The sum of\", a, \"and\", b, \"is\", sum)\n</code></pre>"}]}